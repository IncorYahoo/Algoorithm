1	
给定一个正数数组，找出不相邻元素的子序列的和的最大值。如：2、5、3、9应该返回14（5+9）；8、5、3、9、1应该返回17（8+9）；5 4 10 100 10 5应该返回110（5+100+5）；	"输入的第一行指定用例数量T；
用例的第一行输入指定数组长度N；
用例的第二行输入指定N个数组元素C[i]；"	输出子序列的和的最大值	"1 ≤ T ≤ 10
1 ≤ N ≤ 100
0 ≤ C[i] ≤ 500"	"int find_max_sum_without_adjacents(int vec[],int N)
Input:
2
6
5 4 10 100 10 5
4
3 2 7 10

Output:
110
13"
2	
"给定一个链表，实现一个函数，将链表中每k个节点进行翻转，若最后一组节点数量不足k个，则按实际个数翻转。例如：给定链表1->2->3->4->5->6->7->8->NULL，k=3，翻转后输出3->2->1->6->5->4->8->7->NULL。
翻转函数reverse有两个参数，分别为链表头指针和翻转步长k。"	"输入的第一行指定用例数量T；
用例的第一行输入指定链表节点个数N；
用例的第二行输入指定N个节点数值，使用空格隔开；
用例的第三行输入指定翻转步长K；"	按照K翻转后的链表节点值	"1<=T<=10
1<=N<=100
1<=K<=N"	"
Input:
1
8
1 2 2 4 5 6 7 8
4

Output:
4 2 2 1 8 7 6 5"
3	
"输入一个由大写字母‘A-Z’组成的字符串，按照如下方式，对字符串中的字符进行编码：
1.统计每个字符出现的次数，并根据出现次数对字符进行权重分配；
 a.出现次数越高，权重越大；
 b.出现次数相同，字符值越小，权重越大；
 c.权重值为1~26，必须从1开始，连续分配，数值越大，权重越高；
2.把权重最小的两个字符构成二叉树的左右子节点，其和作为根节点（节点值为字符权重）；
 a.若两个子节点值不等，较小值作为左子节点；
 b.若两个子节点值相同（多字符的权重和与另一个字符权重可能相同），则叶子节点作为左子节点；
3.重复过程2，直到根节点值为所有字符的权重和；
4.将树的左边定位0，右边定位1，从根节点到字符节点的路径，即为其编码值；

示例：
1.输入字符串‘MBCEMAMCBA’，各字符出现次数分别为M:3,A:2,B:2,C:2,E:1；
2.根据字符出现次数和字符大小，进行排序，结果为：M>A>B>C>E，对应权重值为 M:5,A:4,B:3,C:2,E:1
3.根据规则生成权重树：
 a.(M:5,A:4,B:3,C:2,E:1)中E:1和C:2值最小，相加得3，则E:1为左节点，C:2为右节点，3为根节点；
 b.(M:5,A:4,B:3,3)中B:3和3值最小，相加得6，则B:3为左节点，3为右节点，6为根节点；
 c.(M:5,A:4,6)中M:5和A:4值最小，相加得9，则A:4为左节点，M:5为右节点，9为根节点；
 d.(6,9)中只有两个值，相加得15，则6为左节点，9为右节点,15为根节点；
 e.根节点达到所有字符的权重和1+2+3+4+5=15，结果如下：
         15
    0/      1\
    6         9
  0/ 1\     0/ 1\
  B:3  3   A:4  M:5
     0/ 1\
    E:1  C:2"	"输入的第一行指定用例数量T；
用例的第一行输入为原始字符串；"	经过编码后的二进制字符串（使用字符'0'和'1'表示比特位0和1）	"1 ≤ T ≤ 10
字符串长度小于等于100"	"// 参数：raw_str     输入字符串
// 参数：encoded_str 编码后的字符串
void str_encoding(const std::string& raw_str, std::string& encoded_str)

Input:
1
MBCEMAMCBA

Output:
11000110101110110110010"
4	
"实现find_sub_string(str1,str2)函数，判断字符串str2在str1中出现的次数。返回str2在str1中出现的次数。
int find_sub_string(const std::string& str1, const string& str2);"	"输入的第一行指定用例数量T；
用例的第一行输入str1；
用例的第二行输入str2；"	回str2在str1中出现的次数。	"1 ≤ T ≤ 10
str1和str2非空且小于100个字符"	"int find_sub_string(const std::string& str1, const string& str2);

Input:
3
abcdefg
bcd
abcdcdc
cdc
aaaaa
aaa

Output:
1
2
3"
5	
"有一个吃金币游戏：
1.地图中有N个城堡（编号分别为0~N-1），每个城堡中挂着一面旗子；
2.某些城堡之间是连通的，在其连通的路上，分散着若干个金币（个数可能相同，也可能不同）；
3.玩家走过存在金币的路之后，可以获得这条路上的所有金币，同一条路走多次，只有第一次可获得金币；

游戏规则：
1.玩家可以从任意一个城堡出发；
2.玩家必须拿到所有城堡的旗子；
3.玩家走过的所有路，不能存在环路；
4.一定存在至少一条能让玩家拿到所有旗子的路线；

请设计一个算法，计算在遵守以上游戏规则的的前提下，最多能获取到的金币个数。

补充规则中对环路的说明：
1、环路就是最终走过的路径中存在圈，实例如下：
非环路：                  环路：1-2-5-4-1则成为环路
1----2    3              1----2----3
       |      |                |    |
       |      |                |    |
4----5----6              4----5----6
|      |       |              |    |
|      |      |               |    |
7    8    9              7    8----9

2、如说明1中的路径，玩家走1-2-5-4-7-4-5，虽然无圈，但是4-7、5-4中的路径金币只能吃一次，重复走第二次金币不可以获取"	"输入的第一行指定用例数量T；
用例的第一行输入指定城堡个数N；
用例的第二行输入指定城堡间连通的路的数量M；
用例的后续行输入指定城堡之间的金币数量，包括三个参数： 出发点城堡编号 目标城堡编号 金币数量，使用空格隔开；"	最多能获取到的金币个数	"N > 1
M >= N
保证所有城堡间存在连通道路
M<30"	"// 记录城堡间路上金币信息的结构体
// 从城堡castle_from到城堡castle_to的路上有coins个金币
struct road{
 int castle_from; 
 int castle_to;   
 int coins;
};

// 计算最多能获取到的金币个数
// 参数：roads         路径和金币信息数组
// 参数：roads_count   roads数量
// 参数：castles_count 城堡个数
// 返回值：获取到的金币个数
int max_coin(const road roads[], int roads_count, int castles_count);


Input:
1
7
9
0 1 10
0 2 6
0 3 5
1 3 15
2 3 4
1 4 3
3 5 3
4 6 9
5 6 7

Output:
50"
6	
"在H.264视频编码标准中，编码帧由NALU头和NALU主体组成，其中NALU头由一个字节组成。在实际编码时，在每个NAL前添加起始码 0x000001，解码器在码流中检测到起始码，当前NAL结束。
为了防止NAL内部出现0x000001的数据，在编码完一个NAL时，如果检测出有连续两个0x00字节，就在后面插入一个0x03。
当解码器在NAL内部检测到0x000003的数据，就把0x03抛弃，恢复原始数据。给定一组包含SPS NALU的编码数据，找出解码后的SPS数据。比如：
输入：{0x1f 0x00 0x00 0x01 0x67 0x42 0xd0 0x80 0x00 0x00 0x03 0x00 0x80 0x00 0x0f 0x00 0x00 0x01 0x68 0xce 0x3c 0x80},
处理：在上述例子中，第一个0x00 0x00 0x01为识别到的数据头，0x00 0x00 0x03 0x00数据中，0x03为需抛弃数据，第二个0x00 0x00 0x01为下一个数据头，那么取出两个数据头中间的数据并且抛弃掉此0x03，结果如下：
{0x67 0x42 0xd0 0x80 0x00 0x00 0x00 0x80 0x00 0x0f }。"	"输入的第一行指定用例的数量T；
用例的第一行输入指定二进制数据长度N；
用例的第二行输入指定N个二进制数据元素C[i]；"	输出解码后的SPS数据	"7 ≤ N ≤ 50
0 ≤ C[i] ≤ 0xff"	"int find_sps_in_h264(unsigned char[],int N)
input:
1
23
0 0 01 67 42 c0 16 d0 80 0 0 03 0 80 0 0f 0 0 01 68 ce 3c 80
output:
67 42 c0 16 d0 80 0 0 0 80 0 0f"
7	
给定一个全小写的英文字符串，请在该字符串中找到一个连续子字符串，使得子字符串没有重复的字符并且长度最长，计算此最长字符串的长度。比如：abcbdeab,最长的子字符串为cbdea，长度为5；aaaa，最长子字串为a，长度为1。	"输入的第一行指定用例数量T；
用例的第一行输入小写字符串；"	输出最长不含重复字符的连续子字串的长度	1<=length of str<=100	"Input: 
2
abcabcdabc
bbbb

Output:
4
1"
8	
一个数可以用二进制表示，也可以用十进制表示，如果该数的二进制表示法所有位数字之和等于十进制表示法所有位数字之和，则称该数为神奇数。比如：21(十进制)=10101(二进制),所有位数之和为2+1=3,1+0+1+0+1=3。求小于等于M的神奇数有多少个。	"输入的第一行指定用例数量T；
用例的第一行输入数字M；"	输出神奇数字的个数	1<=M<=100000	"Input:
2
100
300

Output:
3
11"
9	
我们来玩一个大富翁的游戏，在地图上有N个连续的城市，城市对某件商品的售价为[V1,V2,V3...VN]，你作为未来的大富翁看到其中的商机，打起了倒卖商品赚取差价的主意。约束条件：你只能顺序从第一个城市出发，不能走回头路，每次只能交易一件商品，再下次买入商品后必须卖掉之前买入的商品，求你能赚取的最大财富。比如：城市商品售价为[1,9,2,3,8]，最大财富为(9-1)+(8-2)=14；城市商品售价为[9,8,3,2,1]，最大财富为0，因为你买啥都无法赚钱。	"输入的第一行指定用例数量T；
用例的第一行输入城市的个数n；
用例的第一行输入商品售价，以空格隔开；"	输出赚取的最大财富值	"1<=n<=100
1<=v<=100"	"Input:
2
5
1 9 2 3 8
5
9 8 3 2 1

Output:
14
0"
10	
"假设你站在一棵二叉树的右边，从上往下，请输出你看到的节点。比如：
         5         <---
        / \ 
       2   3       <---
      /   / \
     4   6   8     <---
返回 538。"	"输入的第一行指定用例数量T；
用例的第一行输入二叉树(以先序序列的方式输入，比如题目的二叉树可以用""524###36##8##"")；"	输出从上往下看到的节点序列	输入字符串长度<1000	"Input:
1
524###36##8##

Output:
538"
